
[参考地址](http://c.biancheng.net/view/8385.html)

# 工厂模式

工厂模式的使用频率非常的高，在我们日常的开发中总能见到他们的身影。其定义为：

 > Define an interface for creating an object,but let subclasses decide which cla ss to instantiate.Factory Method lets a class defer instantiation to subclasses.（定义一个用于创建对象的接口，将产品对象的实际创建工作推迟到具体子工厂类当中。工厂方法使一个类的实例化延迟到其子类。）

按实际业务场景划分，工厂模式有三种不同的实现方式，分为简单工厂模式、工厂方法模式以及抽象工厂模式。

## 1. 简单工厂模式

### 1.1. 定义

我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。

在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。

简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。

简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。

> “工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原有代码的情况下引进新的产品，即满足开闭原则。


### 1.2. 优缺点及应用场景

 #### 1.2.1. 优点
 
 - 客户端无需知道所创具体产品的类名，只需知道具体参数即可。
 - 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。
 - 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。
 
 #### 1.2.2. 缺点

- 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。
- 使用简单工厂模式会增加系统中类的个数(引入新的工厂类)，增加系统的复杂度和理解难度。
- 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂。
- 简单工厂模式使用了static工厂方法，造成工厂角色无法形成基于继承的等级结构。
 
 #### 1.2.3. 应用场景
 
 > 对于产品总类相对较少的情况，考虑使用简单工厂模式。客户端只需传入工厂类的参数，无需关心对象创建逻辑，方便创建所需产品。

### 1.3. 模式结构与实现

简单工厂模式的主要角色如下：
 - 简单工厂(SimpleFactory)：是简单工厂模式核心，负责创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外部直接调用，从而创建所需产品。
 - 抽象产品(Product)：是简单工厂创建的所有对象的父类，是所有实例共有的公共接口。
 - 具体产品(ConcreteProduct)：是简单共产模式的创建目标。
 
 具体类图如下：
 
 ![image](https://note.youdao.com/yws/public/resource/df96d20a281a6c544a1a770c9a6382ed/xmlnote/844C538A21404050B46BD47122770558/19362)
 
 
 `其实使用反射是一种不错的办法，但反射也是从类名反射而不能从类反射！
  
  先看一下工厂模式是用来干什么的——属于创建模式，解决子类创建问题的。换句话来说，调用者并不知道运行时真正的类名，只知道从“Circle"可以创建出一个shape接口的类，至于类的名称是否叫'Circle"，调用者并不知情。
  
  所以真正的对工厂进行扩展的方式（防止程序员调用出错）可以考虑使用一个枚举类（防止传入参数时，把circle拼写错误）。
  
  如果调用者参肯定类型是Circle的话，那么其工厂没有存在的意义了！
  
  比如 IShape shape = new Circle();这样不是更好？也就是说调用者有了Circle这个知识是可以直接调用的，根据DP（迪米特法则(最少知识原则)）其实调用者并不知道有一个Circle类的存在，他只需要知道这个IShape接口可以计算圆面积，而不需要知道；
  圆这个类到底是什么类名——他只知道给定一个”circle"字符串的参数,IShape接口可以自动计算圆的面积就可以了！
  
  其实在.net类库中存在这个模式的的一个典型的。但他引入的另一个概念“可插入编程协议”。
  
  那个就是WebRequest req = WebRequest.Create("http://ccc......");可以自动创建一个HttpWebRequest的对象，当然，如果你给定的是一个ftp地址，他会自动创建一个FtpWebRequest对象。工厂模式中着重介绍的是这种通过某个
  
  特定的参数，让你一个接口去干对应不同的事而已！而不是调用者知道了类！
  
  比如如果圆的那个类名叫"CircleShape“呢？不管是反射还是泛型都干扰了你们具体类的生成！其实这个要说明的问题就是这个，调用者（clinet)只知道IShape的存在，在创建时给IShape一个参数"Circle",它可以计算圆的面积之类的工作，
  但是为什么会执行这些工作，根据迪米特法则，client是不用知道的。
  
  我想问一下那些写笔记的哥们，如果你们知道了泛型，那么为什么不直接使用呢？干吗还需要经过工厂这个类呢？不觉得多余了吗？
  
  如果，我只是说如果，如果所有从IShape继承的类都是Internal类型的呢？而client肯定不会与IShape一个空间！这时，你会了现你根本无法拿到这个类名！
  
  Create时使用注册机制是一种简单的办法，比如使用一个枚举类，把功能总结到一处。而反射也是一种最简单的办法，调用者输入的名称恰是类名称或某种规则时使用，比如调用者输入的是Circle，而类恰是CircleShape，那么可以通过
  
  输入+”Shape"字符串形成新的类名，然后从字符串将运行类反射出来！
  
  工厂的创建行为，就这些作用，还被你们用反射或泛型转嫁给了调用者（clinet)，那么，这种情况下，要工厂类何用？！`
 
 

### 1.4. 简单工厂模式在框架源码（JDK和Logback）中的应用


[框架源码地址](http://m.biancheng.net/view/8387.html)


## 2. 工厂方法模式

    > 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
      
     在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。



## 3. 抽象工厂模式



## 4. 总结


### 4.1、一句话概括工厂模式

 简单工厂：一个工厂类，一个产品抽象类。
 
 工厂方法：多个工厂类，一个产品抽象类。
 
 抽象工厂：多个工厂类，多个产品抽象类。

### 4.2、生活中的工厂模式

 简单工厂类：一个麦当劳店，可以生产多种汉堡。
 
 工厂方法类：一个麦当劳店，可以生产多种汉堡。一个肯德基店，也可以生产多种汉堡。
 
 抽象工厂类：百胜餐饮集团下有肯德基和百事公司，肯德基生产汉堡，百事公司生成百事可乐。